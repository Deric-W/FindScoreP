\documentclass[german,proseminar,hyperref,utf8]{zihpub}
\usepackage{copyrightbox}
\usepackage{listings}
\usepackage{pgfplots}

\graphicspath{{graphics/}}

\author{Eric Niklas Wolf}
\title{Score-P Control via Cmake}
\matno{5006150}
\betreuer{William Robert Williams}
\bibfiles{references}
\copyrighterklaerung{\correctme{TODO}}

\begin{document}
    \section{Einleitung}
    \subsection{Ziel und Motivation der Arbeit}
    Profiling und die damit verbundenen Analysewerkzeuge sind essenziell für die Erkennung von
    Optimierungspotenzial und das Messen der Effektivität der umgesetzten Optimierung.

    Da im HPC Umfeld Ausführungsgeschwindigkeit und Effizienz besonders hohe Prioritäten haben existieren
    mehrere~\longcite{Score-P-Paper}{79} Werkzeuge welche an die dort verwendeten Technologien
    und Pradigmen angepasst sind.

    Jedoch fokussieren sich die meisten Tools auf bestimmte Anwendungsfälle und Technologien,
    was dazu führt dass sie je nach Anwendungsfall in Kombination eingesetzt werden müssen.

    Dies wiederum kann dazu führen dass eine Anwendung mehrfach mit unterschiedlichen Werzeugen
    analysiert werden muss wenn diese inkompatibel zueinander sind, was wiederum Redundanz
    und Mehraufwand bedeutet.

    Um dies zu vermeiden existiert mit Score-P~\cite{Score-P-Paper} ein Framework welches erlaubt
    eine Anwendung  einmalig zu instrumentieren und die gewonnenen Daten mit mehreren
    unterschiedlichen Werkzeugen zu analysieren.

    Gleichzeitig nutzen viele Projekte Werkzeuge welche das Bauen und Verwalten einen Projektes
    vereinfachen.

    Ein populäres Werkzeug ist CMake~\cite{CMake-Documentation}, für welches jedoch die Nutzung
    von Score-P manuelle Eingriffe und damit zusätzlichen Aufwand benötigt.

    Das Ziel dieses Proseminars ist ein Modul für CMake zu entwickeln welches diesen Aufwand
    reduziert.


    \subsection{Aufbau}
    Dieses Dokument ist wie folgt aufgebaut.

    Zuerst werden die beiden wichtigsten Technologien (Score-P und CMake) betrachtet um einen
    Überblick über deren Funktionsweise zu geben.

    Anschlie{\ss}end werden die im Rahmen dieses Proseminars geschriebenen Module betrachtet
    und mit der bisherigen Verwendung von Score-P verglichen.

    Zum Schluss wird ein Fazit gezogen und ein Ausblick auf weitere Entwicklungen gegeben.

    \newpage
    \section{Betrachtung Score-P}
    \subsection{Architektur}
    Score-P besteht aus mehreren Komponenten, welche in~\ref{fig:score-p-overview} dargestellt
    und anschlie{\ss}end vorgestellt werden.

    \begin{figure}[ht]
        \begin{center}
            \copyrightbox[b]
                {\includegraphics[width=0.75\textwidth]{score-p-overview.png}}
                {\tiny \url{https://perftools.pages.jsc.fz-juelich.de/cicd/scorep/tags/latest/html/score-p-overview.png}}
            \caption{Score-P Komponenten}
            \label{fig:score-p-overview}
        \end{center}
    \end{figure}

    Der Kern von Score-P besteht aus einer gemeinsamen Messinfrastruktur und darauf aufbauenden
    Integrationen mit unterschiedlichen Profilingschnittstellen.

    Die gesammelten Daten werden wiederum in offenen Datenformaten gespeichert und können
    dadurch von mehreren Werkzeugen verwendet werden.

    \subsubsection{Profilingschnittstellen}
    Neben manueller Instrumentierung durch den Benutzer~\longcite{Score-P-Documentation}{Application Instrumentation}
    besitzt Score-P Integrationen mit folgenden Technologien:

    \paragraph{Compilerinstrumentierung}
    Um Aufrufe von Funktionen aufzuzeichnen kann Score-P den verwendeten Compiler
    anweisen das Betreten und Verlassen dieser durch Aufrufe spezieller Funktionen
    zu markieren~\longcite{Score-P-Documentation}{Application Instrumentation}.

    Dabei ist zu beachten das die Namen der entstehenden Regionen und Art wie diese generiert
    werden von dem verwendeten Compiler abhängig ist.

    Dies ist besonders wichtig wenn die zu instrumentierende Anwendung in C++ geschrieben ist,
    weil einige Compiler kein Filtern der zu instrumentierenden Funktionen erlauben und C++
    Anwendungen häufig viele kleine Funktionen besitzen wessen Instrumentierung einen signifikanten
    Overhead erzeugen kann~\longcite{Score-P-Documentation}{Application Instrumentation}.

    \paragraph{MPI Bibliotheksaufrufe}
    Bei MPI handelt es sich um eine standardisierte Schnittstelle für den Nachrichtenaustausch
    zwischen parallel ablaufenden Prozessen mit eigenen Adressbereichen~\longcite{mpi}{1}.

    Um Aufrufe von MPI Funktionen zu Erkennen und zu Messen wird dafür das im MPI Standard
    spezifizierte `Profiling Interface'~\shortcite{mpi}{717} verwendet.

    Bei der Instrumentierung einer Anwendung wird dafür neben der MPI Implementierung zusätzlich
    gegen eine von Score-P bereitgestellte Bibliothek gelinkt~\longcite{Score-P-Documentation}{Application Instrumentation}.

    \paragraph{SHMEM Bibliotheksaufrufe}
    Bei SHMEM handelt es sich ebenfalls um eine standardisierte Schnittstelle, bei welcher jedoch
    im Gegensatz zu MPI im Rahmen des `Partitioned Global Address Space' Paradigmas von einem
    einzigen globalen Adressbereich ausgegangen wird welcher auf mehrere Ausführungseinheiten
    verteilt sein kann und Datentransfers einseitig ablaufen~\longcite{openshmem}{1}.

    Um Aufrufe von SHMEM Funktionen zu Erkennen und zu Messen wird wie bei MPI auf ein standardisiertes
    `Profiling Interface'~\shortcite{openshmem}{140} zugegriffen welches ein Linken gegen eine von
    Score-P bereitgestellte Bibliothek erfordert~\longcite{Score-P-Documentation}{Application Instrumentation}.

    \paragraph{OpenMP Direktiven und API Aufrufe}
    OpenMP ist im Gegensatz zu den beiden vorherigen Technologien keine Bibliotheksschnittstelle
    sondern eine API welche neben Funktionen auch aus Compilerdirektiven besteht.

    Damit können Anwendungsentwickler Bereiche des Quellcode explizit zur parallelen Ausführung
    innerhalb eines gemeinsamen Adressbereichs~\longcite{openmp}{23} markieren und die Umsetzung 
    dem verwendeten Compiler überlassen.

    Die Verwendung von Compilerdirektiven stellt jedoch auch eine Hürde bei der Instrumentierung dar
    weil das Erkennen und Messen von Funktionsaufrufen nicht ausreicht um die komplette API abzudecken.

    Eine der von Score-P verwendeten Lösungen stellt die Opari2 Komponente dar, welche den Quellcode der
    zu instrumentierenden Anwendung analysiert und Aufrufe von Messfunktionen an bestimmten Stellen
    einfügt~\longcite{Score-P-Documentation}{Introduction}.

    Eine Alternative ist die Verwendung des `OMPT Interface'~\shortcite{openmp}{419}, welches eine
    standardisierte Schnittstelle für die Interaktion mit einer OpenMP Implementierung darstellt.

    Zwar kann dabei auf das Modifizieren von Quellcode und die dadurch entstehende Probleme verzichtet werden,
    jedoch existiert die Schnittstelle erst seit OpenMP 5.0 und wird momentan (Stand 2024) noch nicht von
    GCC, einer weit verbreiteten Compilersammlung, unterstützt~\cite{gomp}. 

    \paragraph{Pthread Bibliotheksaufrufe}
    Pthread, auch bekannt als POSIX Threads, ist die standardisierte Threadingbibliothek auf POSIX-
    kompatiblen Betriebssystemen, welche von Score-P durch das Wrappen von Bibliothekssymbolen
    beim Linken der zu instrumentieren Anwendung mit von Score-P bereitgestellten
    Implementierungen Instrumentiert wird~\longcite{Score-P-Documentation}{Application Instrumentation}.

    \paragraph{OpenCL Bibliotheksaufrufe}
    Bei OpenCL handelt es sich wie bei MPI und SCHMEM um eine standardisierte Bibliotheksschnittstelle,
    welche es Anwendungsentwicklern erlaubt Berechnungen auf verschiedene Hardware wie u.a. einer GPU
    zu verteilen~\longcite{opencl}{2}.
    
    Dabei wird grundsätzlich von mehreren Adressbereichen ausgegangen~\longcite{openmp}{30}.

    Das Instrumentieren wird wie bei Pthread durch das Wrappen von Bibliothekssymbolen beim
    Linken ermöglicht.

    \paragraph{OpenACC Direktiven und API Aufrufe}
    Die API von OpenACC ähnelt der von OpenMP, weil der Anwendungsentwickler ebenfalls durch
    Compilerdirektiven explizit Teile der Anwendung parallel ablaufen lassen kann.

    Im Gegensatz zu OpenMP konzentriert sich OpenACC jedoch auf heterogene Hardware und besitzt
    dementsprechend meistens keinen gemeinsamen Adressbereich, da die ausgeführten Programmteile
    möglicherweise auf anderen Geräten laufen~\longcite{openacc}{11}.

    Beim Instrumentieren von Anwendungen welche OpenACC unterstützen verwendet Score-P das
    `Profiling and Error Callback Interface'~\shortcite{openacc}{123}, wofür wiederum gegen eine
    von Score-P bereitgestellte Bibliothek gelinkt~\longcite{Score-P-Documentation}{Introduction}
    werden muss.

    \paragraph{CUDA}
    CUDA ist eine vom Hersteller NVIDIA entwickelte Werkzeugsammlung welche es erlaubt GPU-basierte
    Anwendungen zu entwickeln und auszuführen~\longcite{nvidia-docs}{CUDA}.

    Score-P erlaubt das Aufzeichnen von Funktionsaufrufen der CUDA API und GPU Aktivitäten mit Hilfe des
    `CUDA Profiling Tools Interface'~\shortcite{nvidia-docs}{CUPTI}~\longcite{Score-P-Documentation}{Application Measurement}.

    \paragraph{HIP}
    Bei HIP handelt es sich wie bei CUDA um eine Werkzeugsammlung für die Entwicklung von GPU-basierten
    Anwendungen welche vom Hersteller AMD als Bestandteil der ROCm Plattform mit einem Fokus auf
    Kompatibilität mit GPUs von sich selbst und NVIDIA entwickelt wurde~\longcite{rocm-docs}{HIP documentation}.

    Wie bei CUDA unterstützt Score-P das Aufzeichnen von Funktionsaufrufen der ROCm API und GPU Aktivitäten,
    wobei eine nicht näher spezifizierte Schnittstelle verwendet wird~\longcite{Score-P-Documentation}{Application Measurement}.

    \paragraph{I/O}
    Funktionsaufrufe von Funktionen bekannter I/O Schnittstellen können durch Score-P aufgezeichnet werden.

    Dabei werden neben den bekannten POSIX Funktionen auch Funktionen der asynchronen POSIX Schnittstelle,
    ISO C und MPI unterstützt~\longcite{Score-P-Documentation}{Introduction}.

    \subsubsection{Datenformate}
    Nach dem Instrumentieren einer Anwendung ermöglicht Score-P zwei Arten der Datenerfassung,
    genannt `tracing' und `profiling'.

    Bei `tracing' werden aufzuzeichnende Ereignisse unter Beibehaltung zeitlicher und örtlicher
    Zusammenhänge im Open Trace Format 2 abgespeichert, welches u.a. von den Werkzeugen Scalasca
    und Vampir verwendet wird~\longcite{Score-P-Documentation}{Application Measurement}.

    Da dies jedoch gro{\ss}e Datenmengen erzeugen kann erlaubt `profiling' das Zusammenfassen von
    Ereignissen innerhalb bestimmter Regionen, wobei die entstehenden Daten im CUBE4 Format
    gespeichert und von Werkzeugen wie Cube und TAU verwendet werden
    können~\longcite{Score-P-Documentation}{Application Measurement}.

    Dabei stellt jede aufgerufene Funktion eine Region dar welche zusammen mit den von ihr
    aufgerufenen Funktionen einen Baum bildet.

    Die entstehenden Aufrufbäume können basierend auf bestimmten Funktionsparametern,
    benutzerdefinierten Phasen und einzelnen Aufrufen weiter unterteilt
    werden~\longcite{Score-P-Documentation}{Application Measurement}.

    \subsection{Anwendung}
    Um eine Anwendung mit Score-P zu instrumentieren wird ein Befehl namens `scorep' zur Verfügung
    gestellt welcher vor die Befehle zum Compilieren und Linken der Anwendung gestellt wird.

    Das damit assoziierte Programm analysiert den übergebenen Befehl und führt die zur Instrumentierung
    notwendigen Aktionen aus, wobei die Berechnung von benötigten Linkerargumenten und zu linkenden
    Bibliotheken von einem weiteren Werkzeug namens `scorep-config' durchgeführt wird~\longcite{Score-P-Documentation}
    {Score-P Tools}.

    Die zu nutzenden Profilingschnittstellen werden über Befehlsargumente ausgewählt oder durch
    Analyse des übergebenen Befehls erkannt, wobei letzteres nicht immer funktioniert~\longcite{Score-P-Documentation}
    {Application Instrumentation}.

    Dabei ist zu beachten dass für jede instrumentierte Anwendung nur ein Threading Paradigma
    (OpenMP oder Pthread) und eine Kommunikationsparadigma (MPI oder SHMEM) ausgewählt werden kann
    und es Einschränkungen bei der Verwendung von Profilingschnittstellen in statischen
    Bibliotheken gibt wenn diese nicht beim Erstellen der fertigen Anwendung aktiviert werden.

    Zusätzlich kann die Unterstützung für bestimmte Profilingschnittstellen bei einer Score-P
    Installation fehlen, was durch die Ausgaben des Befehls `scorep-info' überprüft werden kann.

    Au{\ss}erdem kann bei der Verwendung von Werkzeugen wie CMake und Autotools der konfigurierte Compiler
    bereits vor dem Bauen eines Projektes aufgerufen werden um die Verfügbarkeit von Schnittstellen
    oder andere Informationen für das Konfigurieren des Projektes zu erhalten.

    Da bei der Verwendung von Score-P der `scorep' Befehl als Compiler verwendet wird kann es dabei
    zu Fehlern kommen obwohl Score-P in dieser Phase nicht benötigt wird~\longcite{Score-P-Documentation}
    {Score-P Compiler Wrapper Usage}.

    Um dies zu verhindern stellt Score-P Befehle bereit welche sich normalerweise wie der Befehl
    `scorep' verhalten, durch das Setzen von bestimmten Umgebungsvariablen jedoch den Aufruf an den
    verwendeten Compiler durchreichen~\longcite{Score-P-Documentation}{Score-P Compiler Wrapper Usage}.

    \newpage
    \section{Betrachtung CMake}
    Bei CMake handelt es sich um ein Werkzeug zum Bauen von Softwareprojekten, welches aus in einer
    plattformunabhängigen Sprache definierten Projektbeschreibung die dafür nötigen Schritte
    ermittelt~\longcite{CMake-Documentation}{User Interaction Guide}.

    Die Verwendung von CMake besteht zuerst auf einer Konfigurationsphase in welcher Informationen
    über das aktuelle System gesammelt und die Projektbeschreibung evaluiert wird.

    Zusätzlich können Optionen deklariert werden welche es ermöglichen Einfluss auf den
    Konfigurationsprozess zu nehmen.

    Anschlie{\ss}end wird mit den gesammelten Daten eine Konfiguration für ein plattformspezifisches Werkzeug
    (wie u.a. Unix Makefiles oder Visual Studio~\longcite{CMake-Documentation}{cmake-generators(7)})
    generiert welches das eigentliche Bauen des Projektes
    übernimmt~\longcite{CMake-Documentation}{User Interaction Guide}.

    \subsection{Projektbeschreibung}
    Die Projektbeschreibung ist in einer CMake spezifischen Sprache verfasst welche die Zeichenkette
    als einzigen Datentyp besitzt, wobei Zeichenketten als Werte anderer Datentypen interpretiert
    werden können~\longcite{CMake-Documentation}{cmake-language(7)}.

    Sie besteht aus mehreren `Targets' welche Befehle zum Erreichen eines bestimmten Zustandes wie
    z.B. das Bauen eines ausführbaren Programms repräsentieren~\longcite{CMake-Documentation}{cmake-buildsystem(7)}.

    Ein Target kann von den Ergebnissen anderer Targets abhängen, was dafür sorgt dass vor der
    Ausführung der Befehle eines abhängigen Targets die Befehle der referenzierten Targets ausgeführt werden.

    \subsubsection{Targettypen}
    Neben benutzerdefinierten Targets besitzt CMake bereits vordefinierte Targets zum repräsentieren
    von häufigen Aktionen beim Bauen von Programmen, welche nachfolgend erläutert
    werden~\longcite{CMake-Documentation}{cmake-buildsystem(7)}.

    \paragraph{`EXECUTABLE'} Targets repräsentieren ausführbaren Programme.

    \paragraph{`STATIC\_LIBRARY'} Targets repräsentieren statische Programmbibliotheken welche
    beim Linken anderer Programmteile verwendet werden können.

    \paragraph{`SHARED\_LIBRARY'} Targets repräsentieren dynamische Programmbibliotheken welche
    neben dem Linken anderer Programmteile auch zur Laufzeit geladen werde kann.

    \paragraph{`MODULE\_LIBRARY'} Targets repräsentieren dynamische Programmkomponenten welche
    im Gegensatz zu Bibliotheken nur zur Laufzeit geladen werden.

    \paragraph{`OBJECT\_LIBRARY'} Targets repräsentieren Mengen von bereits zu Objektcode
    compilierten Quelltexten.

    \paragraph{`INTERFACE\_LIBRARY'} Targets repräsentieren Ausführungskonfigurationen welche andere
    Targets durch linken übernehmen können.

    \paragraph{`ALIAS'} Targets repräsentieren andere Targets und können im Gegensatz zu vielen
    anderen Targets nicht verändert werden.

    \paragraph{`IMPORTED'} Targets repräsentieren bereits existierende Objekte welche z.B. durch
    installierte Programme zur Verfügung gestellt werden und können deswegen nicht bearbeitet
    oder erneut gebaut werden.

    \subsubsection{Targeteigenschaften}
    CMake definiert bestimmte Targeteigenschaften welche die Ausführung eines Target beeinflussen,
    wobei eine Auswahl nachfolgend erläutert wird~\longcite{CMake-Documentation}{cmake-properties(7)}.

    An vielen Stellen erlaubt CMake die Verwendung sogenannter `generator expressions', was spezielle
    Ausdrücke sind welche nach der Evaluation der Projektbeschreibung beim Generieren der Werkzeugkonfiguration
    ausgewertet werden~\longcite{CMake-Documentation}{cmake-generator-expressions(7)}.

    Sie erlauben bei Werkzeugen welche mehrere Konfigurationsprofile besitzen ein Anpassen von
    Eigenschaftswerten an das benutzte Profil, was bei der Evaluation der Projektbeschreibung
    noch unbekannt ist und erst im Rahmen der Konfigurationsgenerierung ermittelt werden kann.

    \paragraph{`<LANG>\_COMPILER\_LAUNCHER'} enthält ein Programm welches verwendet werden soll um
    Aufrufe des Compiler einer bestimmten Sprache durchzuführen.

    \paragraph{`<LANG>\_LINKER\_LAUNCHER'} verhält sich wie `<LANG>\_COMPILER\_LAUNCHER' für Aufrufe des Linkers.

    \paragraph{`LINK\_LIBRARIES'} enthält Bibliotheken oder Targets gegen welche das Target gelinkt
    werden soll wobei die Verwendung von `generator expressions' erlaubt ist.

    \paragraph{`INTERFACE\_LINK\_LIBRARIES'} enthält Bibliotheken oder Targets gegen welche beim Linken
    gegen das aktuelle Target zusätzlich gelinkt werden soll wobei die Verwendung von
    `generator expressions' erlaubt ist.

    Dabei ist es unerheblich ob das Linken im Rahmen von `LINK\_LIBRARIES' oder durch Verweise
    in `INTERFACE\_LINK\_LIBRARIES' anderer gelinkter Targets stattfindet.

    \subsection{Module}
    CMake erlaubt es Benutzern Programme welche in der CMake Sprache geschrieben sind wiederzuverwenden
    indem deren Quellcode innerhalb des aktuellen Namensraumes für Variablen durch die `include'
    Funktion evaluiert wird~\longcite{CMake-Documentation}{include}.

    Dabei kann eine bestimmte Datei oder nur der Name des zu ladenden Moduls angegeben werden,
    in welchem Falle die den Quellcode des Moduls enthaltene Datei in Verzeichnissen welche in
    der Variable `CMAKE\_MODULE\_PATH' gespeichert sind gesucht wird.

    Dem gegenüber steht der Begriff des `Package', welcher externe Software welche durch den
    Benutzer beim Bauen des Projektes angefordert werden kann
    beschreibt~\longcite{CMake-Documentation}{cmake-packages(7)}.

    Diese Software wird au{\ss}erhalb von CMake durch den Benutzer installiert und besteht aus
    Sicht von CMake aus importierten Targets oder Variablen mit weiteren Informationen, wobei
    zwei Arten von Packages mit unterschiedlichen Lokalisierungsmechanismen existieren.

    Die erste Art nutzt Module welche den Namen der zu lokalisierenden Software mit einem `Find'
    Präfix tragen und beim Aufruf die zur Lokalisierung der Software notwendigen Schritte
    durchführen~\longcite{CMake-Documentation}{cmake-developer(7)}.

    Dabei müssen diese Module nicht von der zu lokalisierenden Software bereitgestellt werden sondern
    können auch durch den Benutzer in von CMake durchsuchten Verzeichnissen abgelegt werden.

    Die zweite Art nutzt eine Reihe von CMake Dateien mit dem Namen der Software und den Postfix `Config'
    und `Version' welche im Gegensatz zu Find-Modulen zu einer bestimmten Installation der Software
    gehören und von der zu lokalisierenden Software bereitgestellt
    werden~\longcite{CMake-Documentation}{cmake-packages(7)}.

    Dadurch kann ein möglicherweise aufwendiges Untersuchen der Installation auf bestimmte Merkmale
    vermieden werden, jedoch setzt dies voraus dass die zu lokalisierende Software mit CMake
    gebaut wurde oder diese Dateien manuell generiert werden.

    Unabhängig von der Art des Package kann bei dessen Suche eine Versionsnummer
    (im Format Major.Minor.Patch.Tweak) und eine Liste von Komponenten übergeben
    werden~\longcite{CMake-Documentation}{find\_package}.

    Da es sich wie bei allen Variablen in CMake bei ihnen um Zeichenketten handelt ist die Verarbeitung
    der Versionsnummer und Definition der Komponenten abhängig von der Implementierung des Package,
    jedoch ist vorgesehen dass die Version der lokalisierten Software kompatibel zu der übergebenen
    Versionsnummer ist und die lokalisierte Installation die als benötigt deklarierte Komponenten
    besitzt~\longcite{CMake-Documentation}{find\_package}.

    \newpage
    \section{Implementierung}
    Die Implementierung besteht aus zwei getrennten Modulen um die unabhängige Verwendung dieser
    zu ermöglichen.

    \subsection{Lokalisierungsmodul}
    Zum Lokalisieren einer Score-P Installation wurde das Modul `FindScoreP' entwickelt weil
    durch die fehlende Verwendung von CMake durch Score-P die Verwendung von Config-Modulen
    ein manuelles Generieren der benötigten CMake Dateien vorausgesetzt hätte.

    Es unterstützt neben Versionsnummern, welche mit der Funktion `find\_package\_check\_version'
    auf Kompatibilität hin überprüft werden, das Finden einer kompatiblen Version wenn
    mehrere verschiedene Versionen von Score-P installiert sind.

    \subsubsection{Komponenten}
    Da eine Score-P Installation Einschränkungen in den unterstützten Profilingschnittstellen und
    andere Eigenschaften welche für die zu instrumentierende Anwendung von Bedeutung sind besitzen
    kann können diese durch Komponenten abgefragt werden.

    Das Vorhandensein einer Komponente wird durch die Analyse der Ausgabe des Befehls
    `scorep-info config-summary' ermittelt, wobei die verfügbaren Komponenten und ihre
    Bedeutungen nachfolgend erläutert werden.

    \paragraph{`<BACKEND>COMPILER\_<SPRACHE>\_<COMPILER>'} repräsentiert den von einem Score-P Backend
    zum Compilieren einer Sprache verwendeten Compiler, wobei die Backends `MPI\_' für MPI,
    `SHMEM\_' für SHMEM und das leere Backend für den standardmä{\ss}ig verwendeten Compiler existieren.

    Dies ermöglicht es sicherzustellen dass der von Score-P verwendete Compiler mit dem Compiler
    welcher für das zu instrumentierende Projekt konfiguriert wurde übereinstimmt.

    \paragraph{`MPP\_<PARADIGMA>'} repräsentiert die Unterstützung für ein bestimmtes Paradigma zur
    Verwendung mehrerer Prozesse, wobei die Paradigmas `mpi' für MPI und `shmem' für SHMEM existieren.

    \paragraph{`IO\_<PARADIGMA>'} repräsentiert die Unterstützung für ein bestimmtes Paradigma zur
    Aufzeichnung von I/O Operationen, wobei nur das Paradigma `posix' für POSIX Schnittstellen existiert.

    \paragraph{`COMPILER'} repräsentiert die Unterstützung für Compilerinstrumentierung.

    \paragraph{`CUDA'} repräsentiert die Unterstützung für CUDA.
    
    \paragraph{`POMP'} repräsentiert die Unterstützung für eine nicht näher beschriebene Schnittstelle
    names `OPARI2 pomp user instrumentation'.

    \paragraph{`OMP\_<SPRACHE>'} repräsentiert die Unterstützung von OpenMP für eine bestimmte Sprache.

    \paragraph{`OPARI2'} repräsentiert die Verfügbarkeit von Opari2.

    \paragraph{`OMPT'} repräsentiert die Unterstützung der OMPT Schnittstelle.

    \paragraph{`PDT'} repräsentiert die Unterstützung einer nicht näher beschriebenen Schnittstelle
    namens `PDT'.

    \paragraph{`OPENCL'} repräsentiert die Unterstützung von OpenCL.

    \paragraph{`OPENACC'} repräsentiert die Unterstützung von OpenACC.

    \paragraph{`MEMORY'} repräsentiert die Unterstützung des Aufzeichnens der Speicherverwendung.

    \paragraph{`LIBWRAP'} repräsentiert die Unterstützung von Bibliothekswrappern.

    \paragraph{`KOKKOS'} repräsentiert die Unterstützung von Kokkos.

    \paragraph{`HIP'} repräsentiert die Unterstützung von HIP.

    \subsubsection{Lokalisierungsmechanismus}
    Der Mechanismus zum Lokalisieren einer Score-P Installation wird nachfolgend erläutert.

    \begin{enumerate}
        \item Lokalisieren von `scorep-config'

        Dies wird für das Ermitteln des Installationsortes benötigt und durch die CMake Funktion
        `find\_program' durchgeführt.

        Dabei wird bereits für jede lokalisierte Installation überprüft ob diese mit der übergebenen
        Version und den übergebenen Komponenten kompatibel ist um im Falle von mehreren Installationen
        die zu ignorieren welche nicht kompatibel sind.

        \item Ermitteln der Version und des Installationsortes

        Dies wird durch die Befehle `scorep-config --version' und `scorep-config --prefix' erreicht.

        \item Lokalisieren von `scorep' und `scorep-info'

        Dabei kommt wieder die Funktion `find\_program' zum Einsatz wobei die Suche auf den Installationsort
        beschränkt wird um zu verhindern dass Programme anderer Installationen lokalisiert werden.

        \item Überprüfen des Vorhandenseins übergebener Komponenten

        Obwohl dies beim Lokalisieren von `scorep-config' bereits durchgeführt wurde wird es erneut
        durchgeführt um bei der Ermittlung des Lokalisierungsergebnisses benötigte Variablen zu setzen.

        \item Erstellen importierter Targets

        Dieser Schritt wird übersprungen falls die Lokalisierung im Rahmen eines CMake Scripts
        durchgeführt wird und deswegen keine Targets erstellt werden können.

        \item Ermitteln des Lokalisierungsergebnisses

        Dies sorgt dafür das unter anderem Variablen gesetzt werden welche CMake signalisieren ob das
        Lokalisieren erfolgreich war.

        Weil die dafür von CMake bereitgestellte Funktion `find\_package\_handle\_standard\_args' Informationen
        über die existierenden Komponenten in Form von gesetzten Variablen benötigt wird deren
        Vorhandensein vorher erneut überprüft.
    \end{enumerate}
    
    \subsubsection{Ausgaben}
    Im Falle der erfolgreichen Lokalisierung einer Score-P Installation werden die folgenden
    Targets und Variablen erstellt.

    \paragraph{`ScoreP::ScoreP'} ist ein importiertes Target welches die ausführbare Datei
    des `scorep' Befehls repräsentiert.

    Der Pfad dieser Datei wird zusätzlich in der Variable `SCOREP\_EXECUTABLE' gespeichert.

    \paragraph{`ScoreP::Config'} ist ein importiertes Target welches die ausführbare Datei
    des `scorep-config' Befehls repräsentiert.

    Der Pfad dieser Datei wird zusätzlich in der Variable `SCOREP\_CONFIG\_EXECUTABLE' gespeichert.

    \paragraph{`ScoreP::Info'} ist ein importiertes Target welches die ausführbare Datei
    des `scorep-info' Befehls repräsentiert.

    Der Pfad dieser Datei wird zusätzlich in der Variable `SCOREP\_INFO\_EXECUTABLE' gespeichert.

    \paragraph{`SCOREP\_FOUND'} ist eine Variable welche einen Wahrheitswert enthält der angibt
    ob die Lokalisierung erfolgreich war.

    Im Gegensatz zu den anderen Ausgaben wird diese auch im Falle einer fehlgeschlagenen Lokalisierung
    gesetzt.

    \paragraph{`SCOREP\_<KOMPONENTE>\_FOUND'} ist eine Variable welche einen Wahrheitswert enthält
    der angibt ob eine bestimmte übergebene Komponente gefunden wurde.

    \paragraph{`SCOREP\_VERSION\_STRING'} ist eine Variable welche die Version der lokalisierten
    Score-P Installation enthält.

    \subsection{Instrumentierungsmodul}
    Um ein von CMake verwaltetes Projekt zu Instrumentieren stellt dass Modul `ScorePUtilites'
    Funktionen bereit welche sich in eine Low- und High-Level Schnittstelle unterteilen.

    \subsubsection{Low-Level Schnittstelle}
    Die Low-Level Schnittstelle ist darauf ausgerichtet den Entwickler einer Anwendung bei deren
    Instrumentierung zu unterstützen und Ihm dabei grö{\ss}tmögliche Kontrolle zu ermöglichen.

    Dafür wird eine Funktion namens `scorep\_instrument' bereitgestellt welche es erlaubt eine Liste
    von übergebenen Targets für die Verwendung von Score-P zu konfigurieren.

    Dies wird erreicht indem die Targeteigenschaften `<LANG>\_COMPILER\_LAUNCHER' und
    `<LANG>\_LINKER\_LAUNCHER' auf den zu verwendenden Score-P Befehl gesetzt werden um
    das Compilieren und Linken von Score-P durchführen zu lassen.

    Dabei muss durch den Entwickler eine Liste der vom Target verwendeten Programmiersprachen übergeben
    werden weil eine Analyse des Targets durch die Möglichkeit der Verwendung von Generatorausdrücken 
    beim Konfigurieren des CMake Projekts nicht vollständig möglich ist.

    Wenn jedoch der Benutzer die Unvollständigkeit der Analyse für unproblematisch befindet
    kann diese optional verwendet werden um aus den Abhängigkeiten eines Targets seine Score-P
    Einstellungen abzuleiten.

    Au{\ss}erdem muss eine mit den gewählten Befehlen kompatible Score-P Installation vor der Verwendung
    der Schnittstelle durch das Lokalisierungsmodul lokalisiert werden um den Speicherort des
    Score-P Befehls zu ermitteln.

    Der Vorteil von Targeteigenschaften im Vergleich zur Verwendung von einem von Score-P bereitgestellten
    Compilerwrappers ist neben der Fähigkeit der selektiven Instrumentierung von Teilen eines Projektes
    die automatische Verwendung des vom Nutzer konfigurierten Compilers beim Konfigurieren des Projektes.

    \subsubsection{High-Level Schnittstelle}
    Da wie bereits erwähnt Einschränkungen bei der Auswahl verschiedener Score-P Einstellungen wie zum
    Beispiel des zu verwendenden Threading Paradigmas existieren kann es bei der manuellen Instrumentierung
    von einzelnen Targets zu fehlerhaften Konfigurationen kommen.

    Um dies zu vermeiden existiert neben der Low-Level Schnittstelle eine High-Level Schnittstelle
    welche es dem Entwickler der zu instrumentieren Anwendung erlaubt im Austausch für Kontrolle
    über den Instrumentierungsprozess erforderliche Score-P Einstellungen automatisch zu ermitteln.

    Diese Schnittstelle sieht vor dass im Gegensatz zur Low-Level Schnittstelle die Instrumentierung
    in mehreren Phasen erfolgt um die übergebenen Informationen zu analysieren.

    Zuerst werden die zu instrumentierenden Targets mit der Funktion `scorep\_mark' über Targeteigenschaften
    als solche markiert und die gewünschten Score-P Einstellungen mit einer vom Benutzer vorgegebenen
    Priorität gespeichert.

    Die Priorität ermöglicht es bei der Targetanalyse dem Benutzer seine Präferenzen im Falle von
    in Konflikt stehenden Einstellungswerten auszudrücken.

    Anschlie{\ss}end wird mit der Funktion `scorep\_determine\_instrumentations' durch eine Analyse der Targets
    die endgültigen Score-P Einstellungen ermittelt und ebenfalls als Targeteigenschaften gespeichert.

    Zum Schluss wird eine Score-P Installation lokalisiert und mit der Funktion `scorep\_enable'
    die ermittelten Einstellungen über die Low-Level Schnittstelle angewendet, wobei die im vorherigen
    Schritt erfolgte Analyse die zur Instrumentierung benötigten Komponenten ermitteln kann.

    \subsubsection{Targetanalyse}
    Die zum Ermitteln der endgültigen Score-P Einstellungen durchgeführte Targetanalyse der High-Level
    Schnittstelle wird an dem nachfolgendem Beispiel erläutert.

    \begin{figure}[ht]
        \begin{center}
            \includegraphics[width=0.75\textwidth]{analysis_before.drawio.png}
            \caption{Beispiel einer Projektkonfiguration}
            \label{fig:analysis_example}
        \end{center}
    \end{figure}

    In dem Beispiel existieren eine Reihe von Targets mit durch gestrichelte Linien dargestellten
    Abhängigkeiten beim Linken, welche neben statischen Bibliotheken sogenannte `standalone Targets'
    beinhalten.

    Diese `standalone Targets' beinhalten alle Targettypen von CMake welche einen sogenannten
    Konstruktor besitzen und damit im Rahmen der meisten Score-P Einstellungen nicht an die
    zu instrumentierende Anwendung gebunden sind, wozu neben `EXECUTABLE' und `SHARED\_LIBRARY'
    auch Targets des Typs `MODULE\_LIBRARY' zählen.

    Zusätzlich handelt es sich bei den analysierten Abhängigkeiten nur um solche welche keine
    Generatorausdrücke verwenden weil diese sonst nicht während des Konfigurierens des CMake
    Projekts evaluiert werden könnten.

    Zu diesen Einstellungen zählen wie bereits erwähnt nicht das verwendete Threading und
    Kommunikationsparadigma, welche innerhalb einer Anwendung eindeutig sein müssen.

    Im Gegensatz dazu besitzen statische Bibliotheken keinen eigenen Konstruktor und müssen deswegen
    die gleichen Score-P Einstellungen wie die Programme verwenden in welche sie gelinkt werden, was
    dazu führen kann dass Targets welche ursprünglich nicht als zu instrumentierend markiert wurden
    trotzdem instrumentiert werden müssen wenn sie gegen eine als solche markierte statische
    Bibliothek linken.

    Um diese Einschränkungen nicht zu verletzen werden Mengen von Targets ermittelt welche im
    Hinblick auf eine Menge von Score-P Einstellungen im Falle einer Instrumentierung durch
    Score-P die gleichen Einstellungswerte besitzen müssen.

    Die erste Art dieser Mengen wird im nachfolgendem Text `lokale Abhängigkeiten' genannt und
    besteht für jedes standalone Target aus seinen transitiven Abhängigkeiten welche sich
    seinen Konstruktor teilen.

    Innerhalb dieser Mengen darf nur eine Score-P Konfiguration existieren welche auf alle zu
    instrumentierenden Targets angewendet wird, wobei im Falle von instrumentierten Abhängigkeiten
    das der Menge zugeordnete standalone Target ebenfalls instrumentiert wird falls dies nicht
    bereits dazu markiert wurde.

    Um eindeutige Threading und Kommunikationsparadigma auch über Abhängigkeiten mit eigenen
    Konstruktoren hinweg sicherzustellen existiert zusätzlich eine zweite Art von Mengen, welche
    nachfolgend `globale Abhängigkeiten' genannt werden.

    Diese Mengen sind Erweiterungen der lokalen Abhängigkeiten welche zusätzlich alle transitiven
    Abhängigkeiten enthalten und nur die verwendeten Threading und Kommunikationsparadigma einschränken.

    Gleichzeitig kann ein Target nicht mit mehreren unterschiedlichen Score-P Konfigurationen
    instrumentiert werden, was zu Konflikten führen kann wenn ein Target in mehreren dieser
    Mengen enthalten ist und für diese unterschiedliche Score-P Einstellungen ermittelt werden.

    Um dies zu verhindern werden Mengen welche sich zu instrumentierende Targets mit anderen
    Mengen teilen mit diesen vereint, wobei eine Union-Find-Datenstruktur zum Einsatz kommt.
    
    Im Beispiel würde dies bedeuten dass folgende Mengen existieren:

    \begin{align*}
        \text{lokale Abhängigkeiten} &= \{ \{ B, D, F, G, C \}, \{ A, D \}, \{ E, H \} \} \\
        \text{globale Abhängigkeiten} &= \{ \{ A, B, C, D, E, F, G, H \} \} \\
        \text{zu instrumentierende Targets} &= \{ B, C, G \}
    \end{align*}

    Da einige Mengen keine zu instrumentierenden Targets enthalten können diese ignoriert werden.

    Falls für eine Score-P Einstellung mehrere Werte innerhalb einer Menge existieren müssen diese
    zusammengeführt oder falls dies nicht möglich ist ein Fehler gemeldet werden.

    Bei dem Zusammenführen von zwei Einstellungswerten wird zuerst versucht den Wert mit der höchsten
    Priorität zu verwenden.

    Ist dies aufgrund gleicher Prioritäten nicht möglich wird versucht ob die beiden Werte kompatibel
    sind, was zum Beispiel der Fall sein kann wenn es sich um die selben Werte handelt oder ein
    Wert eine spezifischere Version des anderen darstellt.

    Ist dies ebenfalls nicht möglich wird ein Konflikt gemeldet, wobei dies bis zum Zusammenführen
    aller Einstellungswerte verzögert wird um das Überschreiben des Konfliktes zu ermöglichen falls
    andere Werte mit einer höheren Priorität existieren.


    \newpage
    \section{Leistungsanalyse}
    Zur Beurteilung der Nützlichkeit der entwickelten CMake Module wird nachfolgend deren Anwendung
    am Beispiel der GROMACS~\cite{gromacs} Anwendung gezeigt und mit Alternativen verglichen.

    \subsection{bisherige Umsetzung}
    Die bisherige Umsetzung bestand aus der Verwendung der Score-P Wrapper~\longcite{Score-P-Documentation}
    {Score-P Compiler Wrapper Usage}, welche wie bei der Betrachtung von Score-P bereits erwähnt das
    Setzen von bestimmten Umgebungsvariablen vor dem Konfigurieren des CMake Projekts voraussetzt.

    \begin{lstlisting}[language=bash, caption=Anwendung eines Score-P Wrapper bei GROMACS, gobble=8, showstringspaces=false, basicstyle=\small]
        export SCOREP_WRAPPER_INSTRUMENTER_FLAGS= \
        "--thread=omp:ompt --io=posix --compiler"
        SCOREP_WRAPPER=off cmake -S . -B build -DGMX_BUILD_OWN_FFTW=ON \
        -DCMAKE_CXX_COMPILER=scorep-clang++
    \end{lstlisting}

    Neben einer Konfiguration des Projektes au{\ss}erhalb der von CMake dafür vorgesehen Mechanismen
    wie zum Beispiel der CMake Sprache erlaubt es diese Umsetzung aufgrund der Verwendung globaler
    Umgebungsvariablen nicht die Instrumentierung einzelner Targets zu steuern.

    Dies sorgt in diesem Beispiel dafür dass ein in Score-P existierender Fehler welcher durch das
    fehlerhafte Linken von statischen Bibliotheken ein Bauen der Anwendung unmöglich macht
    nur unter hohen Aufwand umgangen werden könnte.

    Zusätzlich wird der Konfigurationsprozess des Projektes komplizierter weil neben dem Setzen der
    benötigten Umgebungsvariablen die von CMake Parametern abhängige Auswahl der Score-P Einstellungen
    au{\ss}erhalb von CMake (zum Beispiel durch ein externes Script oder den Entwickler) erfolgen muss.

    \subsection{Umsetzung durch Module}
    Bei der Verwendung der entwickelten CMake Module kann hingegen auf eine Konfiguration au{\ss}erhalb
    von CMake verzichtet und damit die Komplexität des Konfigurationsprozesses begrenzt werden.

    \begin{lstlisting}[caption=Anwendung der entwickelten Module bei GROMACS, gobble=8, showstringspaces=false, basicstyle=\small]
        option(ENABLE_SCOREP "Enable Score-P instrumentation" OFF)
        if(ENABLE_SCOREP)
            include(ScorePUtilities)
        
            scorep_discover_targets(allTargets)
            scorep_discover_targets(targets src api)
            set(targetsToInstrument "")
            foreach(target ${targets})
                if(NOT target MATCHES "test")
                    list(APPEND targetsToInstrument "${target}")
                endif()
            endforeach()
            
            if(GMX_OPENMP)
                # prevent Opari2 instrumentation
                scorep_mark(
                    INSTRUMENT "${targetsToInstrument}"
                    LANGS CXX
                    ARGUMENTS "--compiler" "--thread=omp:ompt"
                    AUTO
                )
            else()
                scorep_mark(
                    INSTRUMENT "${targetsToInstrument}"
                    LANGS CXX
                    ARGUMENTS "--compiler"
                    AUTO
                )
            endif()
            scorep_determine_instrumentations(
                "${allTargets}"
                COMPONENTS_VAR scorepComponents
            )
            scorep_infer_components(CXX inferredComponents)
            list(APPEND scorepComponents ${inferredComponents})
            list(REMOVE_DUPLICATES scorepComponents)
            find_package(ScoreP REQUIRED COMPONENTS ${scorepComponents})
            scorep_enable("${allTargets}")
        endif()
    \end{lstlisting}

    Durch die Verwendung einer Option namens `ENABLE\_SCOREP' kann die Entscheidung ob Score-P verwendet
    werden soll im Rahmen von CMake und damit auch interaktiv durch darauf aufbauende Werkzeuge erfolgen.

    \begin{lstlisting}[caption=Aktivieren von Score-P bei GROMACS, gobble=8, showstringspaces=false, basicstyle=\small, language=bash]
        cmake -S . -B build -DGMX_BUILD_OWN_FFTW=ON -DENABLE_SCOREP=ON
    \end{lstlisting}

    Zusätzlich kann auf die CMake Projektbeschreibung zugegriffen und damit die benötigten Score-P Argumente
    ermittelt werden, was in diesem Fall ein automatisches Anpassen der Score-P Argumente an die
    durch den Benutzer gewählten Projekteinstellungen ermöglicht.

    Die einzige dafür notwendige Veränderung war die Verwendung des `MPI::MPI\_CXX' Targets welches
    als moderne Schnittstelle zu der von CMake lokalisierten MPI Installation von den entwickelten
    Modulen verwendet wird um die Verwendung von MPI zu erkennen.

    Da GROMACS aktuell noch ältere Schnittstellen nutzt müsste die Verwendung von MPI alternativ
    manuell basierend auf den von GROMACS bereitgestellten Optionen erkannt werden, wobei es bereits
    Bemühungen gibt auf die moderne Schnittstelle zu wechseln~\longcite{gromacs-git}{Issues/\#3672}.

    Neben dem automatisches Anpassen der Score-P Argumente erlaubt der Zugriff auf die CMake
    Projektbeschreibung auch ein Umgehen des in Score-P existierenden Fehlers welcher bei der
    Verwendung eines Score-P Wrappers ein Bauen unmöglich gemacht hatte.

    Da dieser beim Linken des `libgromacs' Targets die Reihenfolge der zu linkenden Bibliotheken
    verändert kann durch eine manuelle Verwendung von `scorep-config' und anschlie{\ss}endem Anpassen
    der Targeteigenschaften die Anwendung erfolgreich gebaut werden.

    \begin{lstlisting}[caption=Workaround für Score-P Bug, gobble=8, showstringspaces=false, basicstyle=\small]
        get_target_property(scorepArguments libgromacs SCOREP_CXX_ARGUMENTS)
        set_property(TARGET libgromacs PROPERTY CXX_LINKER_LAUNCHER)
        execute_process(
            COMMAND "${SCOREP_CONFIG_EXECUTABLE}"
            ${scorepArguments} --ldflags
            OUTPUT_VARIABLE ldflags
            COMMAND_ERROR_IS_FATAL ANY
        )
        execute_process(
            COMMAND "${SCOREP_CONFIG_EXECUTABLE}"
            ${scorepArguments} --event-libs
            OUTPUT_VARIABLE eventLibs
            COMMAND_ERROR_IS_FATAL ANY
        )
        execute_process(
            COMMAND "${SCOREP_CONFIG_EXECUTABLE}"
            ${scorepArguments} --mgmt-libs
            OUTPUT_VARIABLE mgmtLibs
            COMMAND_ERROR_IS_FATAL ANY
        )
        string(REGEX REPLACE "[     ]+" ";" ldflags "${ldflags}")
        string(REGEX REPLACE "[     ]+" ";" eventLibs "${eventLibs}")
        string(REGEX REPLACE "[     ]+" ";" mgmtLibs "${mgmtLibs}")
        target_link_options(libgromacs BEFORE PRIVATE ${ldflags})
        target_link_libraries(libgromacs PRIVATE ${eventLibs})
        target_link_libraries(libgromacs PRIVATE ${mgmtLibs})
    \end{lstlisting}

    \subsection{Laufzeit}
    Die Kosten der automatischen Anpassung der Score-P Argumente und der dafür nötigen Targetanalyse
    ist eine spürbare Verzögerung beim Konfigurieren von GROMACS.

    Um dies genauer zu untersuchen wurde in~\ref{fig:runtime} ein Beispielprojekt mit einer beliebigen
    Grö{\ss}e generiert wessen zum Instrumentieren benötigte Zeit gemessen wurde.
    Das Beispielprojekt besitzt eine gewünschte Anzahl an standalone Targets welche jeweils gegen vier
    statische Bibliotheken linken um ein gro{\ss}es Projekt zu simulieren.
    Zusätzlich linkt jedes standalone Target gegen zwei zufällige Targets um die Laufzeit der
    Vereinigung von Abhängigkeitsmengen zu messen.
    Um Rückschlüsse auf das Laufzeitverhalten beim Instrumentieren von Teilmengen der Targets
    zu ziehen wurden mehrere Messungen mit unterschiedlichen Prozentsätzen an durch `scorep\_mark'
    markierten Targets durchgeführt.

    \begin{figure}
        \begin{center}
            \begin{tikzpicture}
                \begin{axis}[
                    xlabel=Anzahl der standalone Targets,
                    ylabel=Zeit in Sekunden,
                    width=0.75\textwidth,
                    legend pos=north west
                ]
                    \addplot table [x=targets, y=runtime, col sep=comma] {BenchmarkProject/runtime_100.csv};
                    \addlegendentry{100\% instrumentiert}
                    \addplot table [x=targets, y=runtime, col sep=comma] {BenchmarkProject/runtime_75.csv};
                    \addlegendentry{75\% instrumentiert}
                    \addplot table [x=targets, y=runtime, col sep=comma] {BenchmarkProject/runtime_50.csv};
                    \addlegendentry{50\% instrumentiert}
                    \addplot table [x=targets, y=runtime, col sep=comma] {BenchmarkProject/runtime_25.csv};
                    \addlegendentry{25\% instrumentiert}
                    \addplot table [x=targets, y=runtime, col sep=comma] {BenchmarkProject/runtime_0.csv};
                    \addlegendentry{0\% instrumentiert}
                \end{axis}
            \end{tikzpicture}
            \caption{Zeit zum Instrumentieren des Beispielprojekts}
            \label{fig:runtime}
        \end{center}
    \end{figure}

    Aus den in~\ref{fig:runtime} ermittelten Werten ist ersichtlich dass die Laufzeit superlinear
    mit der Anzahl der Targets wächst, wobei der Prozentsatz der durch `scorep\_mark' markierten Targets
    einen starken Einfluss auf deren Steigung besitzt.
    Dies bedeutet dass bei sehr gro{\ss}en Projekten die benötigte Zeit zur Targetanalyse stark reduziert
    werden kann indem man die Anzahl der zu instrumentierenden Targets einschränkt.
    Messungen der benötigten Zeit zum Instrumentieren des GROMACS Projekts bestätigen diese Schlussfolgerung,
    wobei die benötigte Zeit zum Instrumentieren aller 188 Targets des Projekts 9,14 Sekunden und beim
    Ausschlie{\ss}en von 160 Targets welche Tests repräsentierten 2,03 Sekunden betrug.
    Dabei ist anzumerken dass die restliche Konfiguration des Projekts ungefähr 26 Sekunden benötigte.

    \newpage
    \section{Fazit}
    Die entwickelten Module erlauben eine im Vergleich zu der bisherigen Lösung flexiblere und einfachere
    Anwendung von Score-P auf CMake basierte Projekte.

    Durch die Aufteilung in Lokalisierungs und Instrumentierungsmodul und in Low-Level und High-Level
    Schnittstelle ist es zudem möglich den Grad der Abstraktion zu wählen.

    Der Preis für einen höheren Abstraktionsgrad ist jedoch eine Targetanalyse wessen Laufzeit
    mit zunehmender Anzahl an Targets superlinear wächst.

    Obwohl diese Zeitspanne bei dem untersuchten `GROMACS' Projekt nur wenige Sekunden dauerte
    kann sie bei grö{\ss}eren Projekten einen erheblichen Teil der Konfigurationszeit einnehmen, wobei
    die Verwendung einer Schnittstelle mit geringerem Abstraktionsgrad (wie zum Beispiel die Low-Level
    Schnittstelle) die Analysephase auf Kosten von mehr manueller Konfiguration überspringen kann.


    \section{Ausblick}
    Wie bereits erwähnt ist das Laufzeitverhalten der Targetanalyse ungeeignet für sehr gro{\ss}e Projekte.

    Um dies zu verbessern kann deren aktuelle Implementierung auf Optimierungspotential wie Caching
    hin untersucht oder wegen dem Mangel an komplexen Datenstrukturen in CMake in ein externes
    Programm ausgelagert werden.

    Zudem können die Annahmen auf welchen die Targetanalyse basiert überprüft und gegebenenfalls von
    Score-P explizit dokumentiert werden um zukünftige Verwendungen zu erleichtern.
    
    Gleichzeitig trifft Annahme alle dass alle lokalen Abhängigkeiten die selben Score-P Einstellungen
    benötigen nur auf einige Einstellungen zu was für mehr Flexibilität ebenfalls untersucht werden kann.

    \newpage
    \listoffigures
\end{document}
